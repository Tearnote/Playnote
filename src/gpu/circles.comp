/*
Copyright (c) 2025 Tearnote (Hubert Maraszek)

Licensed under the Mozilla Public License Version 2.0 <LICENSE-MPL-2.0.txt
or https://www.mozilla.org/en-US/MPL/2.0/> or the Boost Software License <LICENSE-BSL-1.0.txt
or https://www.boost.org/LICENSE_1_0.txt>, at your option. This file may not be copied, modified,
or distributed except according to those terms.
*/

#version 460
#pragma shader_stage(compute)
#extension GL_EXT_shader_image_load_formatted: enable

layout(local_size_x = 16, local_size_y = 16) in;

struct Circle {
    vec2 pos;
    float radius;
    float _pad0;
    vec4 color;
};

layout(binding = 0, std430) restrict readonly buffer Circles {
    Circle b_circles[];
};
layout(binding = 1) restrict uniform image2D i_target;

layout(push_constant) uniform push_constants {
    uint circle_count;
    float timer;
} C;

#define PI 3.14159265359
layout(constant_id = 0) const uint ViewportWidth = 0;
layout(constant_id = 1) const uint ViewportHeight = 0;
layout(constant_id = 2) const float WindowScale = 0.0;
const uvec2 ViewportSize = uvec2(ViewportWidth, ViewportHeight);

float circle_sdf(vec2 p, float radius)
{
    return length(p) - radius;
}

float cos_shutter(float t) {
    if (t < 0.0) return 0.0;
    if (t > 1.0) return 1.0;
    return t - sin(2.0 * PI * t) / (2.0 * PI);
}

float motion_blurred_circle_coverage(vec2 p, vec2 v, float r)
{
    float a = dot(v, v);
    if (a < 0.0001) {
        float dist = length(p) - r;
        return clamp(0.5 - dist, 0.0, 1.0);
    }

    float b = -2.0 * dot(p, v);
    float c = dot(p, p) - r * r;

    float delta = b * b - 4.0 * a * c;
    if (delta < 0.0) return 0.0;

    float sqrt_delta = sqrt(delta);
    float t1 = (-b - sqrt_delta) / (2.0 * a);
    float t2 = (-b + sqrt_delta) / (2.0 * a);

    float overlap_start = max(0.0, t1);
    float overlap_end = min(1.0, t2);
    return cos_shutter(overlap_end) - cos_shutter(overlap_start);
}

void main()
{
    uvec2 gid = gl_GlobalInvocationID.xy;
    if (any(greaterThanEqual(gid, ViewportSize))) return;

    vec2 velocity = vec2(12.0 * sin(C.timer * 1.7), 8.0 * cos(C.timer * 2.5)) * WindowScale;

    vec4 color = imageLoad(i_target, ivec2(gid));
    for (int i = 0; i < C.circle_count; i += 1) {
        Circle circle = b_circles[i];
        circle.pos *= WindowScale;
        circle.radius *= WindowScale;
        vec2 center = vec2(gid) - circle.pos;
        float alpha = motion_blurred_circle_coverage(center, velocity, circle.radius);
        color = mix(color, circle.color, circle.color.a * alpha);
    }
    imageStore(i_target, ivec2(gid), color);
}
