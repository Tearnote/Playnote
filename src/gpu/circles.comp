/*
Copyright (c) 2025 Tearnote (Hubert Maraszek)

Licensed under the Mozilla Public License Version 2.0 <LICENSE-MPL-2.0.txt
or https://www.mozilla.org/en-US/MPL/2.0/> or the Boost Software License <LICENSE-BSL-1.0.txt
or https://www.boost.org/LICENSE_1_0.txt>, at your option. This file may not be copied, modified,
or distributed except according to those terms.
*/

#version 460
#pragma shader_stage(compute)
#extension GL_EXT_shader_image_load_formatted: enable

layout(local_size_x = 16, local_size_y = 16) in;

struct Circle {
    vec2 position;
    vec2 velocity;
    vec4 color;
    float radius;
    float _pad0[3];
};

layout(binding = 0, std430) restrict readonly buffer Circles {
    Circle b_circles[];
};
layout(binding = 1) restrict uniform image2D i_target;

layout(push_constant) uniform push_constants {
    uint circle_count;
    float timer;
} C;

const float Pi = 3.14159265359;
layout(constant_id = 0) const uint ViewportWidth = 0;
layout(constant_id = 1) const uint ViewportHeight = 0;
layout(constant_id = 2) const float WindowScale = 0.0;
const uvec2 ViewportSize = uvec2(ViewportWidth, ViewportHeight);

vec4 blend(vec4 onto, vec4 color)
{
    return mix(onto, color, color.a);
}

float circle_sdf(vec2 p, float radius)
{
    return length(p) - radius;
}

// Antiderivative of the cosine shutter function
// https://www.shadertoy.com/view/cdXSRn
float cos_shutter(float t)
{
    if (t < 0.0) return 0.0;
    if (t > 1.0) return 1.0;
    return t - sin(2.0 * Pi * t) / (2.0 * Pi);
}

float motion_blurred_circle_coverage(vec2 p, vec2 v, float r)
{
    float a = dot(v, v);
    if (a < 0.0001) {
        float dist = length(p) - r;
        return clamp(0.5 - dist, 0.0, 1.0);
    }

    float b = -2.0 * dot(p, v);
    float c = dot(p, p) - r * r;

    float delta = b * b - 4.0 * a * c;
    if (delta < 0.0) return 0.0;

    float sqrt_delta = sqrt(delta);
    float t1 = (-b - sqrt_delta) / (2.0 * a);
    float t2 = (-b + sqrt_delta) / (2.0 * a);

    float overlap_start = max(0.0, t1);
    float overlap_end = min(1.0, t2);
    return cos_shutter(overlap_end) - cos_shutter(overlap_start);
}

vec4 draw_circle(Circle circle, vec2 at)
{
    circle.position *= WindowScale;
    circle.velocity *= WindowScale;
    circle.radius *= WindowScale;
    vec2 center = at - circle.position;
    float alpha = motion_blurred_circle_coverage(center, circle.velocity, circle.radius);
    return circle.color * alpha;
}

void main()
{
    uvec2 self_id = gl_GlobalInvocationID.xy;
    if (any(greaterThanEqual(self_id, ViewportSize))) return;
    vec2 self_pos = vec2(self_id) + vec2(0.5);

    vec4 color = imageLoad(i_target, ivec2(self_id));
    for (int i = 0; i < C.circle_count; i += 1) {
        vec4 new_color = draw_circle(b_circles[i], self_pos);
        color = blend(color, new_color);
    }
    imageStore(i_target, ivec2(self_id), color);
}
